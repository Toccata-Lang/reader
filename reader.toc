
;; This file specifies the syntax of Toccata
;; It also contains the code to turn a Toccata program from a string
;; to an AST

;; Components to build the grammar out of
(add-ns grmr (git-dependency "https://github.com/Toccata-Lang/grammar.git"
                             "grammar.toc"
                             :sha "e8eba87"))

;; The different types of nodes in the AST
(add-ns ast (git-dependency "https://github.com/Toccata-Lang/ast.git"
                            "ast.toc"
                            :sha "70df31c"))

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "a4c915d"))

(def lflf "\n\n")

(defn min [x y]
  (either (< x y)
          y))

;; sometimes, we have to see what's wrong
(defn debug [tag]
  (grmr/ignore
   (apply-to (fn [file line text]
               (print-err (str file ": " line) tag (count text)
                          (str "\"" (subs text 0 (min 40 (count text))) "\"")))
             (grmr/get-value 'file-name)
             (grmr/get-value 'line-number)
             grmr/get-text)))

(def not-eol
  (grmr/rule "not-eol"
             (grmr/not-char "\n")))

(def linear-whitespace
  (grmr/rule "linear-whitespace"
             (grmr/any "," " " "\t")))

(def ignore-linear-whitespace (grmr/ignore (grmr/none-or-more linear-whitespace)))

(def newline
  (grmr/rule "newline"
             (apply-to identity
                       (grmr/string-terminal "\n")
                       (grmr/ignore (grmr/update-value 'line-number inc)))))

(def ignore-newlines (grmr/ignore (grmr/none-or-more newline)))

(def whitespace
  (grmr/rule "whitespace"
             (grmr/any (grmr/all (grmr/one-or-more ";")
                                 (grmr/none-or-more not-eol)
                                 newline)
                       linear-whitespace
                       "\r"
                       newline)))

(def ignore-whitespace (grmr/ignore (grmr/none-or-more whitespace)))

(def read-block-comment
  (grmr/rule "block-comment"
             (apply-to ast/block-comment
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/one-or-more
                        (apply-to to-str
                                  (grmr/ignore (grmr/none-or-more (grmr/any linear-whitespace
                                                                            "\r"
                                                                            newline)))
                                  (grmr/ignore (grmr/one-or-more ";"))
                                  (grmr/none-or-more not-eol)
                                  (grmr/ignore newline))))))

(def read-open-paren
  (grmr/rule "open-paren"
             (grmr/ignore (grmr/all ignore-whitespace "("))))

(def read-close-paren
  (grmr/rule "close-paren"
             (grmr/any (grmr/ignore (grmr/all ignore-whitespace ")"))
                       (grmr/error "Missing \")\"."))))

(def read-open-bracket
  (grmr/rule "open-bracket"
             (grmr/any (grmr/ignore (grmr/all ignore-whitespace "["))
                       (grmr/error "Missing \"[\"."))))

(def read-close-bracket
  (grmr/rule "close-bracket"
             (grmr/any (grmr/ignore (grmr/all ignore-whitespace "]"))
                       (grmr/error "Missing \"]\"."))))

(def symbol-start
  (grmr/rule "symbol-start"
               (grmr/any grmr/alpha (grmr/one-of "._<>=+-*/"))))

(def symbol-punct
  (grmr/rule "symbol-punct"
               (grmr/one-of "._<>=+-*?")))

(def symbol-char
  (grmr/rule "symbol-char"
               (grmr/any grmr/alpha grmr/digit symbol-punct)))

(def rest-of-symbol
  (grmr/rule "rest-of-symbol"
               (grmr/none-or-more symbol-char)))

(def namespace-punct
  (grmr/rule "namespace-punct"
               (grmr/one-of "._<>=*+-?")))

(def rest-of-namespace
  (grmr/rule "rest-of-namespace"
             (grmr/none-or-more (grmr/any grmr/alpha
                                          grmr/digit
                                          namespace-punct))))

(def read-namespace
  (grmr/rule "namespace"
             (apply-to (fn [start the-rest]
                         (symbol (to-str (comp [start] the-rest))))
                       grmr/alpha
                       rest-of-namespace
                       (grmr/ignore "/"))))

(def read-symbol
  (grmr/rule "tagged-symbol"
             (apply-to (fn [file-name line-number ns start the-rest]
                         (let [ns-prefix (cond (= c/no-symbol ns)
                                               ""

                                               (str ns "/"))]
                           (c/TaggedSymbol ns
                                           (symbol (to-str (comp [start] the-rest)))
                                           (symbol (to-str (comp (list ns-prefix start)
                                                                 the-rest)))
                                           (c/Location file-name line-number)
                                           c/no-symbol "" c/top-type)))
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/optional read-namespace c/no-symbol)
                       symbol-start
                       rest-of-symbol)))

(def read-arg
  (grmr/rule "arg"
             (apply-to comp
                       ignore-whitespace
                       read-symbol
                       ignore-whitespace)))

(def read-var-arg
  (grmr/rule "var-arg"
             (grmr/any (apply-to identity
                                 ignore-whitespace
                                 (grmr/ignore "&")
                                 read-arg)
                       (grmr/always c/no-symbol))))

(def read-sub-dest
  (grmr/recurse "destructure"))

(def read-list-destructure
  (grmr/rule "list-destructure"
             (apply-to ast/params
                       ignore-whitespace
                       (grmr/ignore "[")
                       (grmr/none-or-more read-sub-dest)
                       read-var-arg
                       read-close-bracket)))

(def read-destructure
  (grmr/rule read-sub-dest
             (grmr/any read-list-destructure
                       read-arg)))

(def read-string-newline
  (grmr/rule "newline"
             (apply-to (fn [& _] "\n")
                       (grmr/all "\\" "n"))))

(def read-string-tab
  (grmr/rule "tab"
             (apply-to (fn [& _] "\t")
                       (grmr/all "\\" "t"))))

(def read-string-backspace
  (grmr/rule "backspace"
             (apply-to (fn [& _] "\b")
                       (grmr/all "\\" "b"))))

(def read-string-return
  (grmr/rule "return"
             (apply-to (fn [& _] "\r")
                       (grmr/all "\\" "r"))))

(def read-string-formfeed
  (grmr/rule "formfeed"
             (apply-to (fn [& _] "\f")
                       (grmr/all "\\" "f"))))

(def read-string-doublequote
  (grmr/rule "doublequote"
             (apply-to (fn [& _] "\"")
                       (grmr/all "\\" "\""))))

(def read-string-backslash
  (grmr/rule "backslash"
             (apply-to (fn [& _] "\\")
                       (grmr/all "\\" "\\"))))

(defn string-frag-len [s]
  (assert (instance? String s))
  (inline C Integer "
    char *str = NULL;
    int64_t strLen;
    if (s_0->type == StringBufferType) {
      str = ((String *)s_0)->buffer;
      strLen = ((String *)s_0)->len;
    } else if (s_0->type == SubStringType) {
      str = ((SubString *)s_0)->buffer;
      strLen = ((SubString *)s_0)->len;
    }
    int64_t len;
    for (len = 0; len < strLen && str[len] != 34 && str[len] != 92;)
       len++;
    dec_and_free(s_0, 1);
    return(integerValue(len));
"))

(def read-string-fragment
  (grmr/rule "read-string-fragment"
             (grmr/term-fn (fn [text]
                             (string-frag-len text)))))

(def read-string
  (grmr/rule "string"
             (apply-to to-str
                       (grmr/ignore "\"")
                       (grmr/none-or-more
                        (grmr/any read-string-fragment
                                  read-string-backslash
                                  read-string-doublequote
                                  read-string-tab
                                  read-string-backspace
                                  read-string-return
                                  read-string-formfeed
                                  read-string-newline))
                       (grmr/ignore "\""))))

(def read-string-literal
  (grmr/rule "string"
             (apply-to (fn [file-name line-num frags]
                         (let [str-val (to-str frags)]
                           (ast/string-ast str-val (c/Location file-name line-num)
                                           ""
                                           (.static c/strbuff-constraint str-val))))
                       (grmr/ignore "\"")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/none-or-more
                        (grmr/any read-string-fragment
                                  read-string-backslash
                                  read-string-doublequote
                                  read-string-tab
                                  read-string-backspace
                                  read-string-return
                                  read-string-formfeed
                                  read-string-newline))
                       (grmr/ignore "\""))))

(def read-integer
  (grmr/rule "number"
             (grmr/any (apply-to (fn [digits]
                                   (str-to-int (to-str digits)))
                                 (grmr/one-or-more grmr/digit))
                       (apply-to (fn [digits]
                                   (* -1 (str-to-int (to-str digits))))
                                 (grmr/ignore "-")
                                 (grmr/one-or-more grmr/digit)))))

(def read-integer-literal
  (grmr/rule "number"
             (grmr/any (apply-to (fn [file-name line-num digits]
                                   (let [n (str-to-int (to-str digits))]
                                     (ast/integer-ast n
                                                      (c/Location file-name line-num)
                                                      ""
                                                      (.static c/int-constraint n))))
                                 (grmr/get-value 'file-name)
                                 (grmr/get-value 'line-number)
                                 (grmr/one-or-more grmr/digit))
                       (apply-to (fn [file-name line-num digits]
                                   (let [n (* -1 (str-to-int (to-str digits)))]
                                     (ast/integer-ast n
                                                      (c/Location file-name line-num)
                                                      ""
                                                      (.static c/int-constraint n))))
                                 (grmr/get-value 'file-name)
                                 (grmr/get-value 'line-number)
                                 (grmr/ignore "-")
                                 (grmr/one-or-more grmr/digit)))))

(defn assert-min-count [file-name line-number len]
  ;; TODO: what was I thinking doing it this way. (Actually, I know.)
  (-> (c/seq-c (repeat len c/top-type) c/coll-of-any)
      (c/update-path (c/Location file-name line-number))))

;; TODO: might be useful to have a max count
(def read-min-count-assertion
  (grmr/rule "assert-min-count"
             (apply-to assert-min-count
                       read-open-paren
                       ignore-whitespace
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/ignore "min-count")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any read-integer
                                 (grmr/error "The 'min-count' expression must contain an integer"
                                             "which is the minium length the sequence must have."))
                       read-close-paren)))

(defn assert-max-value [file-name line-number max]
  (-> c/int-constraint
      (.max max)
      (c/update-path (c/Location file-name line-number))))

(def read-max-val-assertion
  (grmr/rule "assert-max"
             (apply-to assert-max-value
                       read-open-paren
                       ignore-whitespace
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/ignore "max-value")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any read-integer
                                 (grmr/error "The 'max' expression must contain an maximum integer value."))
                       read-close-paren)))

(defn assert-min-value [file-name line-number min]
  (-> c/int-constraint
      (.min min)
      (c/update-path (c/Location file-name line-number))))

(def read-min-val-assertion
  (grmr/rule "assert-min"
             (apply-to assert-min-value
                       read-open-paren
                       ignore-whitespace
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/ignore "min-value")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any read-integer
                                 (grmr/error "The 'min' expression must contain an minimum integer value."))
                       read-close-paren)))

(def read-sub-type
  (grmr/recurse "type-expr"))

(def read-type-of-result-type
  (grmr/rule "result-of"
             (apply-to (fn [file line c]
                         (assert-result r (instance? c/SymbolConstraints r))

                         (-> (c/type-op c/call-value-op c c/no-args)
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       (grmr/ignore "result-of")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (grmr/any (apply-to (fn [sym]
                                             (c/TypeOfConstraint sym empty-list c/no-symbol))
                                           read-symbol)
                                 read-sub-type
                                 (grmr/error "Invalid type expression"))
                       read-close-paren)))

(def read-type-of-fn-call
  (grmr/rule "call-fn"
             (apply-to (fn [file line c arg-cs]
                         (assert-result r (instance? c/SymbolConstraints r))

                         (let [arg-cs (comp* [] (seq arg-cs))]
                           (-> (c/type-op c/call-value-op c arg-cs)
                               (c/update-path (c/Location file line)))))
                       read-open-paren
                       (grmr/ignore "call-fn")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (grmr/any (apply-to (fn [sym]
                                             (c/TypeOfConstraint sym empty-list
                                                                 c/no-symbol))
                                           read-symbol)
                                 read-sub-type
                                 (grmr/error "Invalid type expression"))
                       (grmr/any (grmr/one-or-more
                                  (grmr/all ignore-whitespace
                                            (grmr/any (apply-to (fn [sym]
                                                                  (c/TypeOfConstraint sym empty-list
                                                                                      c/no-symbol))
                                                                read-symbol)
                                                      read-sub-type)))
                                 (grmr/error "At least one argument is needed"))
                       read-close-paren)))

(def read-inner-type-of-type
  (grmr/rule "inner-type-of"
             (apply-to (fn [file line c]
                         (assert-result r (instance? c/SymbolConstraints r))

                         (-> (c/type-op c/inner-type-of-op c)
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "inner-type-of")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (grmr/any (apply-to (fn [sym]
                                             (c/TypeOfConstraint sym empty-list c/no-symbol))
                                           read-symbol)
                                 read-sub-type
                                 (grmr/error "Invalid 'inner-type-of' expression"))
                       read-close-paren)))

(def read-type-of-type
  (grmr/rule "type-of"
             (apply-to (fn [file line sym]
                         (-> c/type-of-constraint
                             (.param-sym sym)
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "type-of")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       read-symbol
                       read-close-paren)))

(def read-type-of-arg-type
  (grmr/rule "type-of-arg"
             (apply-to (fn [file line c arg-pos]
                         (assert-result r (instance? c/SymbolConstraints r))

                         (-> (c/type-op c/arg-of-op c (.int arg-pos))
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "type-of-arg")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (apply-to (fn [sym]
                                   (c/TypeOfConstraint sym empty-list c/no-symbol))
                                 read-symbol)
                       ignore-whitespace
                       read-integer-literal
                       read-close-paren)))

(def read-required-arities
  (grmr/rule "required-arities"
             (apply-to (fn [file line arg-counts]
                         ;; ! (vector-of Integer) arg-counts
                         (-> (.required-arities c/fn-constraint arg-counts)
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "required-arities")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (grmr/one-or-more read-integer)
                       read-close-paren)))

(defn assert-map-of [key-type val-type]
  (assert (instance? c/ValueConstraint key-type))
  (assert (instance? c/ValueConstraint val-type))

  (-> ;; (cata (fn [c]
      ;;         (cond (instance? c/HashMapConstraint c)
      ;;               (-> c
      ;;                   (.keys-c key-type)
      ;;                   (.vals-c val-type))

      ;;               c)))
      c/hashmap-constraint
      (c/update-path (ast/location key-type))))

(def read-map-assertion
  (grmr/rule "assert-map-of"
             (apply-to assert-map-of
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "map-of")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       read-sub-type
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any read-sub-type
                                 (grmr/error "The 'map-of' expression must contain one type expression"
                                             "for the key values and one for the mapped values."))
                       read-close-paren)))

(def read-multi-type
  (grmr/rule "multi-type"
             (apply-to c/multi
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "all-of")
                       (grmr/any (grmr/one-or-more read-sub-type)
                                 (grmr/error "The 'all-of' expression must contain at least one"
                                             "type expression."))
                       read-close-paren)))

(defn make-any-of [file line type-exprs]
  (assert (instance? (vector-of c/ValueConstraint) type-exprs))

  (c/SumConstraint type-exprs
                   (list (c/Location file line))
                   c/no-symbol))

(def read-sum-type
  (grmr/rule "sum-type"
             (apply-to make-any-of
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "any-of")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/any (grmr/one-or-more read-sub-type)
                                 (grmr/error "The 'any-of' expression must contain at least one"
                                             "type expression."))
                       read-close-paren)))

(def generic-assertions
  {"contains" (fn [contents]
                (c/CollectionOf contents empty-list c/no-symbol))
   "maybe-of" (fn [contents]
                (c/intersect c/maybe-constraint
                             (c/CollectionOf contents empty-list c/no-symbol)))
   "set-of" (fn [contents]
              (c/intersect c/set-constraint
                           (c/CollectionOf contents empty-list c/no-symbol)))
   "agent-of" (fn [contents]
                (c/intersect c/agent-constraint
                             (c/CollectionOf contents empty-list c/no-symbol)))
   ;; almost certainly can't use this
   ;; "promise-of" (fn [contents]
   ;;                (c/intersect c/promise-constraint
   ;;                             (c/CollectionOf contents empty-list c/no-symbol "")))
   "sequence-of" (fn [contents]
                   (c/seq-c [] (c/coll-of-c contents)))
   "function-returns" (fn [contents]
                        (c/intersect c/fn-constraint
                                     (c/CollectionOf contents empty-list c/no-symbol)))
   })

(def read-generic-type
  (grmr/rule "generic-type"
             (apply-to (fn [base-string file line contents-type]
                         (-> (either (map (get generic-assertions base-string)
                                          (fn [f]
                                            (f contents-type)))
                                     (do
                                       (print-err "No generic type" (str "'" base-string "'")
                                                  "exists. At" file ": " line)
                                       (abort)))
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       ignore-whitespace
                       (apply grmr/any (keys generic-assertions))
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       read-sub-type
                       read-close-paren)))

(def read-type-of-fn-apply
  (grmr/rule "apply-fn"
             (apply-to (fn [file line c arg-cs]
                         (assert-result r (instance? c/SymbolConstraints r))

                         (-> (c/type-op c/apply-op c arg-cs)
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       (grmr/ignore "apply-fn")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (apply-to (fn [sym]
                                   (c/TypeOfConstraint sym empty-list
                                                       c/no-symbol))
                                 read-symbol)
                       ignore-whitespace
                       (apply-to (fn [sym]
                                   (c/TypeOfConstraint sym empty-list
                                                       c/no-symbol))
                                 read-symbol)
                       read-close-paren)))

(def read-seq-items
  (grmr/rule "seq-items"
             (apply-to identity
                       ignore-whitespace
                       (grmr/ignore "[")
                       (grmr/one-or-more read-sub-type)
                       read-close-bracket)))

;; seq-of specifies the kinds of items in the seq
(def read-seq-of
  (grmr/rule "seq-of"
             (apply-to (fn [file line [seq-type] item-types tail-type]
                         (-> (c/seq-c item-types tail-type)
                             (c/set-seq-type seq-type)
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       ignore-whitespace
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/any (grmr/all (grmr/ignore "list-of")
                                           (grmr/always c/ListType))
                                 (grmr/all (grmr/ignore "vector-of")
                                           (grmr/always c/VectorType)))
                       (grmr/optional read-seq-items [])
                       (grmr/optional (apply-to (fn [c]
                                                  (c/CollectionOf c empty-list c/no-symbol))
                                                read-sub-type)
                                      c/no-tail)
                       read-close-paren)))

;; seq-as specifies the specific items and the exact tail constraint
(def read-seq-as
  (grmr/rule "seq-as"
             (apply-to (fn [file line [seq-type] items-types tail-type]
                         (-> (c/seq-c items-types tail-type)
                             (c/set-seq-type seq-type)
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       ignore-whitespace
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       (grmr/any (grmr/all (grmr/ignore "list-as")
                                           (grmr/always c/ListType))
                                 (grmr/all (grmr/ignore "vector-as")
                                           (grmr/always c/VectorType)))
                       (apply-to identity
                                 read-open-bracket
                                 (grmr/none-or-more read-sub-type)
                                 read-close-bracket)
                       (grmr/optional read-sub-type c/no-tail)
                       read-close-paren)))

(def read-concat-type
  (grmr/rule "concat"
             (apply-to (fn [file line c]
                         (assert-result r (instance? c/SymbolConstraints r))

                         (-> (c/type-op c/concat-op c c/no-args)
                             (c/update-path (c/Location file line))))
                       read-open-paren
                       (grmr/ignore "concat")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (grmr/any (apply-to (fn [sym]
                                             (c/TypeOfConstraint sym empty-list c/no-symbol))
                                           read-symbol)
                                 read-seq-as
                                 read-seq-of
                                 (grmr/error "Invalid type expression"))
                       read-close-paren)))

(def seq-assertions
  {"vector-from" c/vect-from-op
   "list-from" c/list-from-op
   "rest-of" c/rest-of-op
   "butlast-of" c/butlast-of-op
   "first-of" c/first-of-op
   "last-of" c/last-of-op})

(def read-seq-type
  (grmr/rule "seq-type"
             (apply-to (fn [base-string file line c]
                         (either (map (get seq-assertions base-string)
                                      (fn [op-c]
                                        (assert-result r (instance? c/SymbolConstraints r))

                                        (-> (c/type-op op-c c)
                                            (c/update-path (c/Location file line)))))
                                 (do
                                   (print-err "No modified sequence type" (str "'" base-string "'")
                                              "exists. At" file ": " line)
                                   (abort))))
                       read-open-paren
                       ignore-whitespace
                       (apply grmr/any (keys seq-assertions))
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (apply-to (fn [sym]
                                   (c/TypeOfConstraint sym empty-list c/no-symbol))
                                 read-symbol)
                       read-close-paren)))

(defn assert-type [type-sym]
   (-> (either (get c/core-type-constraints type-sym)
               (.type-symbol c/empty-reified type-sym))
      (c/update-path (ast/location type-sym))))

(def read-singleton-type
  (grmr/rule "singleton"
             (apply-to identity
                       ignore-whitespace
                       (grmr/any (apply-to (fn [s]
                                             (c/sum-c [(c/SubStrConstraint s empty-list c/no-symbol)
                                                       (c/StrConstraint s)]))
                                           read-string)))))

(def read-type-expr
  (grmr/rule read-sub-type
             (grmr/any read-sum-type
                       read-multi-type
                       read-map-assertion
                       read-seq-of
                       read-seq-as
                       read-generic-type
                       read-type-of-arg-type
                       read-concat-type
                       read-type-of-result-type
                       read-type-of-fn-call
                       read-type-of-fn-apply
                       read-required-arities
                       read-type-of-type
                       read-min-count-assertion
                       read-min-val-assertion
                       read-max-val-assertion
                       read-inner-type-of-type
                       read-seq-type
                       read-singleton-type
                       (apply-to assert-type
                                 ignore-whitespace
                                 read-symbol))))

(def read-type-assertion
  (grmr/rule "assertion-type"
             (apply-to (fn [type-expr sym]
                         (c/update-sym type-expr sym))
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "instance?")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any read-type-expr
                                 (grmr/error "Invalid type expression"))
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any read-symbol
                                 (grmr/error "Missing symbol to assert type of in assertion expression."))
                       read-close-paren)))

(def read-assert
  (grmr/rule "assert"
             (grmr/any (apply-to identity
                                 read-open-paren
                                 (grmr/ignore "assert")
                                 (grmr/ignore (grmr/one-or-more whitespace))
                                 (grmr/any read-type-assertion
                                           ;; put this in if needed
                                           ;; read-show-type
                                           (grmr/error "Missing type assertion in 'assert' expression."))
                                 read-close-paren)
                       (apply-to (fn [sym c]
                                   (assert (instance? c/SymbolConstraints c))

                                   (-> c
                                       (c/update-path (ast/location sym))
                                       (c/update-sym sym)))
                                 ignore-whitespace
                                 (grmr/ignore "!")
                                 (grmr/ignore (grmr/any " " read-string-tab))
                                 ignore-whitespace
                                 read-symbol
                                 ignore-whitespace
                                 (grmr/any read-type-expr
                                           (grmr/error "Missing type assertion in 'assert-result' expression."))
                                 (grmr/ignore (grmr/none-or-more not-eol))
                                 (grmr/ignore newline)))))

(def read-assert-result
  (grmr/rule "assert-result"
             (grmr/any (apply-to (fn [c]
                                   (c/update-sym c ast/result-sym))
                                 read-open-paren
                                 (grmr/ignore "assert-result")
                                 (grmr/ignore (grmr/one-or-more whitespace))
                                 (grmr/ignore (grmr/optional read-symbol))
                                 (grmr/ignore (grmr/one-or-more whitespace))
                                 (grmr/any read-type-assertion
                                           ;; put this in if needed
                                           ;; read-show-type
                                           read-seq-type
                                           (grmr/error "Missing type assertion in 'assert-result' expression."))
                                 read-close-paren)
                       (apply-to (fn [c]
                                   (c/update-sym c ast/result-sym))
                                 ignore-whitespace
                                 (grmr/ignore "!returns")
                                 ignore-whitespace
                                 (grmr/any read-type-expr
                                           (grmr/error "Missing type assertion in 'assert-result' expression."))
                                 (grmr/ignore (grmr/none-or-more not-eol))
                                 (grmr/ignore newline)))))

(def read-inline
  (grmr/rule "read-inline"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "inline")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (apply-to (fn [file-name line-number return-type body]
                                             (ast/inline-ast return-type body
                                                             (c/Location file-name line-number) ""))
                                           (grmr/get-value 'file-name)
                                           (grmr/get-value 'line-number)
                                           (grmr/optional
                                            (apply-to identity
                                                      read-type-expr
                                                      (grmr/ignore (grmr/one-or-more whitespace)))
                                            c/top-type)
                                           (grmr/any read-string
                                                     (grmr/error "The code to be inlined must be a"
                                                                 "string literal."))

                                           read-close-paren)
                                 (grmr/error "Invalid inline expression.")))))

(def read-inline-body
  (grmr/rule "read-inline-body"
             (apply-to conj
                       (grmr/none-or-more (grmr/any read-assert
                                                    read-assert-result
                                                    read-block-comment))
                       ignore-whitespace
                       read-inline
                       (grmr/ignore (grmr/none-or-more read-block-comment)))))

(def read-sub-expr
  (grmr/recurse "expr"))

(def read-call
  (grmr/rule "call"
             (apply-to ast/call-expr
                       read-open-paren
                       (grmr/one-or-more read-sub-expr)
                       read-close-paren)))

(def read-fn-doc
  (grmr/rule "fn-doc"
             (grmr/any read-block-comment
                       (apply-to (fn [fn ln]
                                   (ast/block-comment fn ln [""]))
                                 (grmr/get-value 'file-name)
                                 (grmr/get-value 'line-number)
                                 ;; TODO: actually read the comment lines
                                 ))))

(def read-impl-arity
  (grmr/rule "impl-arity"
             (apply-to (fn [params doc body]
                         (ast/fn-arity params doc body))
                       (apply-to ast/params
                                 ignore-whitespace
                                 (grmr/ignore "[")
                                 (grmr/one-or-more read-sub-dest)
                                 read-var-arg
                                 read-close-bracket)
                       read-fn-doc
                       (grmr/any read-inline-body
                                 (grmr/one-or-more read-sub-expr)
                                 (grmr/error "Body of function is wrong."))
                       ignore-whitespace)))

(def read-implementation
  (grmr/rule "protocol-implementation"
             (apply-to (fn [fn-sym arity]
                         (.fn-sym arity fn-sym))
                       ignore-whitespace
                       (grmr/ignore (grmr/optional read-symbol))
                       read-open-paren
                       (grmr/any read-symbol
                                 (grmr/error "A prototype function implementation must have a name."))
                       read-impl-arity
                       read-close-paren)))


(def read-proto-impls
  (grmr/rule "protocol-implementations"
             (grmr/none-or-more
              (grmr/any read-assert
                        read-block-comment
                        read-implementation))))

(def read-reify
  (grmr/rule "reify"
             (apply-to (fn [impls]
                         (ast/reified c/no-int impls))
                       read-open-paren
                       (grmr/ignore "reify")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       read-proto-impls
                       read-close-paren)))

(def curr-file-name
  (grmr/rule "_FILE_"
             (apply-to (fn [file-name line-num]
                         (ast/string-ast file-name (c/Location file-name line-num)
                                         ""
                                         (c/StrConstraint file-name)))
                       ignore-whitespace
                       (grmr/ignore "_FILE_")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number))))

(def curr-line
(grmr/rule "_LINE_"
           (apply-to (fn [file-name line-num]
                       (ast/integer-ast line-num (c/Location file-name line-num)
                                        ""
                                        (c/IntConstraint line-num)))
                     ignore-whitespace
                     (grmr/ignore "_LINE_")
                     (grmr/get-value 'file-name)
                     (grmr/get-value 'line-number))))

(def read-vector
  (grmr/rule "vector"
             (apply-to identity
                       (grmr/ignore "[")
                       (apply-to (fn [fn ln elems]
                                   (ast/call-expr (cons (c/tag 'vector (c/Location fn ln))
                                                        (seq elems))))
                                 (grmr/get-value 'file-name)
                                 (grmr/get-value 'line-number)
                                 (grmr/none-or-more read-sub-expr)
                                 read-close-bracket))))

(def read-hash-map
  (grmr/rule "hash-map"
             (apply-to identity
                       (grmr/ignore "{")
                       (apply-to (fn [fn ln elems]
                                   (ast/call-expr (cons (c/tag 'hash-map (c/Location fn ln))
                                                        (comp* empty-list elems))))
                                 (grmr/get-value 'file-name)
                                 (grmr/get-value 'line-number)
                                 (grmr/none-or-more (grmr/all read-sub-expr
                                                              read-sub-expr))
                                 (grmr/any (grmr/ignore "}")
                                           (grmr/error "Missing \"}\"."))))))

(def read-hash-set
  (grmr/rule "hash-set"
             (apply-to identity
                       (grmr/ignore "#{")
                       (apply-to (fn [fn ln elems]
                                   (ast/call-expr (cons (c/tag 'hash-set (c/Location fn ln))
                                                        (seq elems))))
                                 (grmr/get-value 'file-name)
                                 (grmr/get-value 'line-number)
                                 (grmr/none-or-more read-sub-expr)
                                 (grmr/any (grmr/ignore "}")
                                           (grmr/error "Missing \"}\"."))))))

(defprotocol QuoteLiteral
  (quote-literal [quoted]
    (ast/quoted quoted)))

(extend-type ast/string-ast
  QuoteLiteral
  (quote-literal [n] n))

(extend-type ast/integer-ast
  QuoteLiteral
  (quote-literal [n] n))

(extend-type String
  QuoteLiteral
  (quote-literal [n] n))

(extend-type Integer
  QuoteLiteral
  (quote-literal [n] n))

(extend-type List
  QuoteLiteral
  (quote-literal [quoted-list]
    (either (or (for [head (first quoted-list)
                      :when (= head 'quoted)
                      ast (quote-literal (rest quoted-list))]
                  ast)
                (for [coll-builder (first quoted-list)
                      :when (or (= coll-builder 'hash-map)
                                (= coll-builder 'vector))
                      :let [frms (rest quoted-list)]
                      contents (or (empty? frms)
                                   (maybe (map frms quote-literal)))]
                  (ast/call-ast (c/tag 'vector (ast/location quoted-list))
                                (vec contents)
                                "" c/top-type)))
            (ast/call-ast (c/tag 'list (ast/location quoted-list))
                          (vec (map quoted-list quote-literal))
                          "" c/top-type))))

(extend-type Vector
  QuoteLiteral
  (quote-literal [quoted-vect]
    (either (or (for [head (first quoted-vect)
                      :when (= head 'quoted)
                      ast (quote-literal (rest quoted-vect))]
                  ast)
                (for [coll-builder (first quoted-vect)
                      :when (or (= coll-builder 'hash-map)
                                (= coll-builder 'vector))
                      :let [frms (rest quoted-vect)]
                      contents (or (empty? frms)
                                   (maybe (map frms quote-literal)))]
                  (ast/call-ast (c/tag 'vector (ast/location quoted-vect))
                                contents "" c/top-type)))
            (ast/call-ast (c/tag 'list (ast/location quoted-vect))
                          (map quoted-vect quote-literal)
                          "" c/top-type))))

(def quoted-value (grmr/recurse "quoted-value"))

(def read-quoted-value
  (grmr/rule quoted-value
             (apply-to identity
                       ignore-whitespace
                       (grmr/any (apply-to identity
                                           read-open-paren
                                           (grmr/none-or-more quoted-value)
                                           read-close-paren)
                                 (apply-to (fn [xs]
                                             (cons 'vector (seq xs)))
                                           (grmr/ignore "[")
                                           (grmr/one-or-more quoted-value)
                                           read-close-bracket)
                                 read-integer-literal
                                 read-string-literal
                                 read-symbol)
                       ignore-whitespace)))

(def read-quoted
  (grmr/rule "quoted"
             (apply-to quote-literal
                       (grmr/ignore "'")
                       read-quoted-value)))

(def read-either
  (grmr/rule "either"
             (apply-to ast/either-expr
                       read-open-paren
                       (grmr/ignore "either")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       read-sub-expr
                       (grmr/any read-sub-expr
                                 (grmr/error "Missing 'either' clause."))
                       read-close-paren)))

(defn nest-thread-exprs [first-expr exprs]
  (let [[first-expr & exprs] (remove (cons first-expr (seq exprs))
                                     (partial instance? ast/NoCode))]
    (reduce exprs first-expr (fn [threaded expr]
                               (ast/call-ast (.call-target expr)
                                             (comp [threaded] (.args expr))
                                             "" c/top-type)))))

(def read-thread-expr
  (grmr/rule "->exp"
             (grmr/any (apply-to identity
                                 (grmr/any (apply-to (fn [sym]
                                                       (ast/call-expr [sym]))
                                                     read-symbol)
                                           read-call)
                                 ignore-whitespace)
                       read-block-comment)))

(def read-threading
  (grmr/rule "->"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "->")
                       (grmr/any (apply-to nest-thread-exprs
                                           (grmr/any read-sub-expr
                                                     (grmr/error "A threading expression may not"
                                                                 "be empty."))
                                           (grmr/any (grmr/one-or-more read-thread-expr)
                                                     (grmr/error "A threading expression must have"
                                                                 "at least one function call.")))
                                 (grmr/error "Invalid '->' expression."))
                       read-close-paren)))

(def read-single-arity
  (grmr/rule "single-arity"
             (apply-to (fn [params doc body]
                         (ast/fn-arity params doc body))
                       read-list-destructure
                       read-fn-doc
                       (grmr/any read-inline-body
                                 (grmr/one-or-more read-sub-expr)
                                 (grmr/error "Body of function is wrong."))
                       ignore-whitespace)))

(def read-arities
  (grmr/rule "arities"
             (grmr/any (apply-to vector read-single-arity)
                       (apply-to (fn [doc arities]
                                   (map arities (fn [arity]
                                                  (.doc arity doc))))
                                 read-fn-doc
                                 (grmr/one-or-more (apply-to identity
                                                             read-open-paren
                                                             read-single-arity
                                                             read-close-paren))))))

(def read-fn
  (grmr/rule "fn"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "fn")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (apply-to (fn [name arity]
                                             (.fn-sym arity name))
                                           (grmr/optional read-symbol c/no-symbol)
                                           ignore-whitespace
                                           read-single-arity
                                           read-close-paren)
                                 (grmr/error "Invalid 'fn' expression.")))))

(def read-let-binding
  (grmr/rule "let-binding"
             (apply-to ast/binding
                       ignore-whitespace
                       read-destructure
                       read-sub-expr)))

(def read-do
  (grmr/rule "do"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "do")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (apply-to ast/do-expr
                                           (grmr/one-or-more read-sub-expr)
                                           read-close-paren)
                                 (grmr/error "Invalid 'do' expression")))))

(def read-let
  (grmr/rule "let"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "let")
                       ignore-whitespace
                       (grmr/ignore "[")
                       (grmr/any (apply-to ast/let-expr
                                           (grmr/one-or-more read-let-binding)
                                           read-close-bracket
                                           (grmr/one-or-more read-sub-expr)
                                           read-close-paren)
                                 (grmr/error "Invalid 'let' expression")))))

(def read-or
  (grmr/rule "or"
             (apply-to ast/or-expr
                       read-open-paren
                       (grmr/ignore "or")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (grmr/one-or-more read-sub-expr)
                                 (grmr/error "An 'or' expression must contain at least one clause."))
                       read-close-paren)))

(def read-and
  (grmr/rule "and"
             (apply-to ast/and-expr
                       read-open-paren
                       (grmr/ignore "and")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (grmr/one-or-more read-sub-expr)
                                 (grmr/error "An 'and' expression must contain at least one clause."))
                       read-close-paren)))

(def read-cond-val
  (grmr/rule "cond-value"
             (apply-to ast/cond-val-expr
                       read-sub-expr
                       read-sub-expr)))

(def read-cond
  (grmr/rule "cond"
             (apply-to ast/cond-expr
                       read-open-paren
                       (grmr/ignore "cond")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/one-or-more read-cond-val)
                       (grmr/any read-sub-expr
                                 (grmr/error "Missing 'cond' default clause."))
                       read-close-paren)))

(def wrapper-sym (c/tag "#wrapper"))

(def read-for-when
  (grmr/rule "for-when"
             (apply-to (fn [fn ln clause]
                         (ast/cond-ast clause (ast/block-comment fn ln [])
                                       (ast/call-ast (c/tag 'zero (c/Location fn ln))
                                                     [wrapper-sym] "" c/top-type)
                                       "" c/top-type))
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (grmr/ignore ":when")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       read-sub-expr)))

(def read-for-when-not
  (grmr/rule "for-when-not"
             (apply-to (fn [fn ln clause]
                         (ast/cond-ast clause (ast/call-ast (c/tag 'zero (c/Location fn ln))
                                                            [wrapper-sym] "" c/top-type)
                                       (ast/block-comment fn ln [])
                                       "" c/top-type))
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (grmr/ignore ":when-not")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       read-sub-expr)))

(def read-for-let
  (grmr/rule "for-let"
             (apply-to identity
                       ignore-whitespace
                       (grmr/ignore ":let")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       read-open-bracket
                       (grmr/one-or-more read-let-binding)
                       read-close-bracket
                       ignore-whitespace)))

(def read-for-binding
  (grmr/rule "for-binding"
             (grmr/any read-for-let
                       read-for-when
                       read-for-when-not
                       read-let-binding
                       (apply-to identity
                                 read-block-comment
                                 ignore-whitespace))))

(defn nest-for-exprs [fst rst body]
  (assert (instance? ast/binding-ast fst))
  (assert (instance? (vector-of (any-of ast/binding-ast
                                        ast/cond-ast
                                        Vector))
                     rst))
  (cond (empty? rst)
        (ast/call-ast (c/tag 'map (ast/location fst))
                      [(.val fst)
                       (ast/fn-arity
                        (ast/params [(.binding fst)])
                        "" [body])]
                      "" c/top-type)
        
        (let [[cont] (-> (reverse rst)
                         (reduce [body (maybe nothing)]
                                 (fn [[cont map?] expr]
                                   (cond (instance? Vector expr)
                                         [(ast/cond-expr expr cont) map?]

                                         (instance? ast/binding-ast expr)
                                         [(ast/call-ast (cond map?
                                                              (c/tag 'map (ast/location expr))
                                                              (c/tag 'flat-map (ast/location expr)))
                                                        [(.val expr)
                                                         (ast/fn-arity
                                                          (ast/params [(.binding expr)])
                                                          "" [cont])]
                                                        "" c/top-type)
                                          nothing]

                                         (instance? ast/cond-ast expr)
                                         [(cond (instance? ast/block-comment-ast (.value expr))
                                                (.value expr cont)
                                                (.cont expr cont))
                                          map?]

                                         (do
                                           (print-err "Parser error" _FILE_ _LINE_)
                                           (abort))))))
              wrapper (c/tag (gensym "wrap") (ast/location fst))]
          (ast/binding-ast wrapper (.val fst)
                           [(ast/call-ast (c/tag 'flat-map (ast/location fst))
                                           [wrapper
                                            (ast/fn-arity
                                             (ast/params [(.binding fst)])
                                             ""
                                             [(cata (fn [x]
                                                      (cond (= x wrapper-sym)
                                                            wrapper
                                                            x))
                                                    cont)])]
                                           "" c/top-type)]
                           ""
                           c/top-type))))

(def read-for
  (grmr/rule "for"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "for")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (apply-to nest-for-exprs
                                           read-open-bracket
                                           (grmr/any read-let-binding
                                                     (grmr/error "Invalid initial 'for' binding."))
                                           (grmr/any (grmr/none-or-more read-for-binding)
                                                     (grmr/error "Invalid 'for' bindings."))
                                           read-close-bracket
                                           (grmr/any (grmr/any read-sub-expr
                                                               (grmr/error "The body of a 'for' expression"
                                                                           " must have a single"
                                                                           " expression in it."))
                                                     (grmr/error "Invalid 'for' body.")))
                                 (grmr/error "Invalid 'for' expression."))
                       (grmr/any (grmr/ignore
                                  (grmr/all read-sub-expr
                                            (grmr/error "The body of a 'for'"
                                                        "expression may only have"
                                                        "one expression in it.")))
                                 read-close-paren))))

(def read-expr
  (grmr/rule read-sub-expr
             (apply-to identity
                       ignore-whitespace
                       (grmr/any read-integer-literal
                                 read-string-literal
                                 curr-file-name
                                 curr-line
                                 read-symbol
                                 read-quoted
                                 read-or
                                 read-and
                                 read-either
                                 read-cond
                                 read-fn
                                 read-let
                                 read-do
                                 ;; read-apply-to
                                 read-reify
                                 read-vector
                                 read-hash-map
                                 read-hash-set
                                 read-for
                                 read-threading
                                 read-assert
                                 read-assert-result
                                 (grmr/all read-inline
                                           (grmr/error "'inline' expressions not allowed here."))
                                 read-call
                                 read-block-comment)
                       ignore-whitespace)))

(def read-prototype
  (grmr/rule "prototype"
             (grmr/any read-assert
                       (apply-to identity
                                 read-open-paren
                                 (grmr/any
                                  (apply-to ast/prototype
                                            (grmr/any read-symbol
                                                      (grmr/error "Every prototype function must"
                                                                  "have a unique name."))
                                            read-list-destructure
                                            read-fn-doc
                                            (grmr/any read-inline-body
                                                      (grmr/none-or-more read-expr))
                                            read-close-paren)
                                  (grmr/error "Invalid prototype function."))))))

(def read-defprotocol
  (grmr/rule "defprotocol"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "defprotocol")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (apply-to
                                  (fn [sym prototypes]
                                    (ast/protocol
                                     sym (remove prototypes (partial instance? ast/NoCode))))
                                  (grmr/any read-symbol
                                            (grmr/error "'defprotocol' must be followed by"
                                                        "the name of the protocol."))
                                  ;; TODO: much too complex. should be
                                  ;; (grmr/none-or-more read-prototype)
                                  ;; but this gives better error messages
                                  (apply-to (fn [comms protos]
                                              (comp* comms (seq protos)))
                                            (grmr/none-or-more read-block-comment)
                                            (grmr/all (grmr/any (grmr/one-or-more read-prototype)
                                                                (grmr/error "A protocol definition must"
                                                                            "contain at least one prototype"
                                                                            "function defintion."))
                                                      (grmr/none-or-more
                                                       (grmr/any read-prototype
                                                                 read-block-comment))))
                                  read-close-paren)
                                 (grmr/error "Invalid 'defprotocol' expression.")))))

(def read-defn
  (grmr/rule "defn"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "defn")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (apply-to (fn [name arity]
                                             (ast/definition name
                                               [arity]))
                                           (grmr/any read-symbol
                                                     (grmr/error "'defn' must be followed by"
                                                                 "the name of the function."))
                                           (grmr/ignore (grmr/one-or-more whitespace))
                                           read-single-arity
                                           read-close-paren)
                                 (grmr/error "Invalid 'defn' expression.")))))

(def read-def
  (grmr/rule "def"
             (apply-to ast/annotated
                       read-open-paren
                       (grmr/ignore "def")
                       (grmr/ignore (grmr/one-or-more whitespace))
                       (grmr/any (apply-to (fn [sym value]
                                             (ast/definition sym [value]))
                                           (grmr/any read-symbol
                                                     (grmr/error "'def' must be followed by the name"
                                                                 "of the value being defined."))
                                           ignore-whitespace
                                           (grmr/any read-inline
                                                     ;; TODO: only for backward compatibility
                                                     ;; remove after bootstrapping
                                                     (grmr/rule read-sub-type
                                                                (grmr/any read-sum-type
                                                                          read-multi-type
                                                                          read-map-assertion
                                                                          read-seq-of
                                                                          read-seq-as
                                                                          read-generic-type
                                                                          read-type-of-arg-type
                                                                          read-concat-type
                                                                          read-type-of-result-type
                                                                          read-type-of-fn-call
                                                                          read-type-of-fn-apply
                                                                          read-required-arities
                                                                          read-type-of-type
                                                                          read-min-count-assertion
                                                                          read-min-val-assertion
                                                                          read-max-val-assertion
                                                                          read-inner-type-of-type
                                                                          read-seq-type))
                                                     read-expr)
                                           ignore-whitespace
                                           read-close-paren)
                                 (apply-to ast/declare
                                           read-symbol
                                           read-close-paren)
                                 (grmr/error "Invalid 'def' expression.")))))

(def read-extend-type
  (grmr/rule "extend-type"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "extend-type")
                       (grmr/any (apply-to ast/extend-ast
                                           (grmr/ignore
                                            (grmr/one-or-more whitespace))
                                           (grmr/any read-symbol
                                                     (grmr/error "'extend-type' must be followed by a"
                                                                 "type name."))
                                           ignore-whitespace
                                           read-proto-impls
                                           read-close-paren)
                                 (grmr/error "Invalid 'extend-type' expression.")))))

(def read-type-const
  (grmr/rule "type-const"
             (apply-to (fn [sym fields impls]
                         (ast/type-ast sym fields impls))
                       ignore-whitespace
                       read-symbol
                       read-list-destructure
                       read-proto-impls)))

(def read-deftype
  (grmr/rule "deftype"
             (apply-to identity
                       read-open-paren
                       (grmr/ignore "deftype")
                       (grmr/any (apply-to (fn [sym type-c]
                                             (ast/definition sym [type-c]))
                                           (grmr/ignore
                                            (grmr/one-or-more whitespace))
                                           (grmr/any read-symbol
                                                     (grmr/error "'deftype' must be followed by a"
                                                                 "type name."))
                                           read-type-expr)
                                 (apply-to (fn [sym type-constructors]
                                             (ast/rec-type-ast sym type-constructors))
                                           (grmr/ignore (grmr/one-or-more whitespace))
                                           (grmr/any read-symbol
                                                     (grmr/error "'deftype' must be followed by a"
                                                                 "type name."))
                                           (grmr/one-or-more
                                            (apply-to identity
                                                      read-open-paren
                                                      read-type-const
                                                      read-close-paren)))
                                 read-type-const
                                 (grmr/error "Invalid 'deftype' expression."))
                       read-close-paren)))

(def bad-expr
  (grmr/rule "bad-expr"
             (grmr/all ignore-whitespace "("
                       (grmr/error "Invalid expression"))))

;; TODO: for regression testing type checker
(def read-sub-exp-type
  (grmr/recurse "expected-type"))

(def type-literals {"empty-list" empty-list
                    "c/empty-list-constraint" c/empty-list-constraint
                    "c/empty-vect-constraint" c/empty-vect-constraint
                    "c/list-constraint" c/list-constraint
                    "c/vect-constraint" c/vect-constraint
                    "c/seq-constraint" c/seq-constraint
                    "c/no-symbol" c/no-symbol
                    "c/no-tail" c/no-tail
                    "c/no-int" c/no-int
                    "c/no-string" c/no-string
                    "c/no-fields" c/no-fields
                    "c/no-args" c/no-args
                    "c/variadic" c/variadic
                    "c/top-type" c/top-type
                    "c/bottom-type" c/bottom-type
                    "c/fn-constraint" c/fn-constraint
                    "c/arity-constraint" c/arity-constraint
                    "c/int-constraint" c/int-constraint
                    "c/maybe-constraint" c/maybe-constraint
                    "c/empty-reified" c/empty-reified
                    "c/hashmap-constraint" c/hashmap-constraint
                    "c/bitmap-constraint" c/bitmap-constraint
                    "c/array-constraint" c/array-constraint
                    "c/hash-coll-constraint" c/hash-coll-constraint
                    "c/promise-constraint" c/promise-constraint
                    "c/future-constraint" c/future-constraint
                    "c/inner-type-of-op" c/inner-type-of-op
                    "c/string-constraint" c/string-constraint
                    "c/strbuff-constraint" c/strbuff-constraint
                    "c/substr-constraint" c/substr-constraint
                    "c/empty-fn-constraint" c/empty-fn-constraint
                    "c/list-from-op" c/list-from-op
                    "c/vect-from-op" c/vect-from-op
                    "c/arg-of-op" c/arg-of-op
                    "c/call-value-op" c/call-value-op
                    "c/concat-op" c/concat-op
                    "c/apply-op" c/apply-op
                    "c/first-of-op" c/first-of-op
                    "c/last-of-op" c/last-of-op
                    "c/rest-of-op" c/rest-of-op
                    "c/butlast-of-op" c/butlast-of-op
                    ;; "c/get-from-op" c/get-from-op
                    ;; "c/set-to-op" c/set-to-op
                    })

(def read-type-literal
  (grmr/rule "type-literal"
             (apply-to (fn [lit-name]
                         (either (get type-literals lit-name)
                                 (do
                                   (print-err "No type literal named" (str "'" lit-name "'")
                                              "exists.")
                                   (abort))))
                       ignore-whitespace
                       (apply grmr/any (keys type-literals)))))

(def type-constraints {"c/AllValues" c/AllValues
                       "c/NoValues" c/NoValues
                       "c/FnConstraint" c/FnConstraint
                       "c/fn-c " c/fn-c
                       "c/fn-arity" c/fn-arity
                       "c/seq-c" c/seq-c
                       "c/vec-c" c/vect-c
                       "c/list-c " c/list-c
                       "c/param " c/param
                       "c/tag" c/tag
                       "c/ParamConstraint" c/ParamConstraint
                       "c/MaybeConstraint" c/MaybeConstraint
                       "c/IntConstraint" c/IntConstraint
                       "c/TypeOfConstraint" c/TypeOfConstraint
                       "c/SymbolConstraint" c/SymbolConstraint
                       "c/StrBuffConstraint" c/StrBuffConstraint
                       "c/SubStrConstraint" c/SubStrConstraint
                       "c/hashmap-c " c/hashmap-c
                       "c/vect-c " c/vect-c
                       "c/AgentConstraint" c/AgentConstraint
                       "c/FutureConstraint" c/FutureConstraint
                       "c/OpaqueConstraint" c/OpaqueConstraint
                       "c/PromiseConstraint" c/PromiseConstraint
                       "c/ReifiedConstraint" c/ReifiedConstraint
                       "c/SumConstraint" c/SumConstraint
                       "c/ProtoImpls" c/ProtoImpls
                       "c/sum-c" c/sum-c
                       "c/multi" c/multi
                       "c/CollectionOf" c/CollectionOf
                       "c/coll-of-c" c/coll-of-c
                       "c/TypeOp" c/TypeOp
                       "c/type-op" c/type-op
                       "c/fn-arity" c/fn-arity
                       "c/intersect" c/intersect
                       "c/reify-type-constraint" c/reify-type-constraint
                       ".required-arities" .required-arities
                       "c/Location" c/Location
                       "symbol" symbol
                       "c/do-call-value" c/do-call-value
                       "=" =
                       })

(def read-type-constraint
  (grmr/rule "type-constraint"
             (apply-to (fn [constraint-name args]
                         (either (map (get type-constraints constraint-name)
                                      (fn [f]
                                        (apply f args)))
                                 (do
                                   (print-err "No constraint named" (str "'" constraint-name "'")
                                              "exists.")
                                   (abort))))
                       read-open-paren
                       ignore-whitespace
                       (apply grmr/any (keys type-constraints))
                       (grmr/one-or-more (apply-to identity
                                                   ignore-whitespace
                                                   (grmr/any read-sub-exp-type
                                                             (apply-to .q-val
                                                                       read-quoted)
                                                             read-string
                                                             read-integer)))
                       read-close-paren)))

(def read-arity-map
  (grmr/rule "arity-map"
             (apply-to identity
                       (grmr/ignore "{")
                       (apply-to (fn [elems]
                                   (reduce elems {} (fn [m [k v]]
                                                      (assoc m k v))))
                                 (grmr/none-or-more (grmr/all ignore-whitespace
                                                              (grmr/any read-integer
                                                                        (apply-to .q-val
                                                                                  read-quoted)
                                                                        read-type-literal)
                                                              (grmr/any read-integer
                                                                        (apply-to .q-val
                                                                                  read-quoted)
                                                                        read-type-literal
                                                                        read-type-constraint)))
                                 ignore-whitespace
                                 (grmr/any (grmr/ignore "}")
                                           (grmr/error "Missing \"}\"."))))))

(def read-expected-type
  (grmr/rule read-sub-exp-type
             (grmr/any read-type-literal
                       read-integer
                       read-string
                       read-arity-map
                       (apply-to identity
                                 (grmr/ignore "[")
                                 (grmr/none-or-more (apply-to identity
                                                              ignore-whitespace
                                                              read-sub-exp-type))
                                 read-close-bracket)
                       (apply-to .q-val
                                 read-quoted)
                       read-type-constraint)))

(def read-is-type
  (grmr/rule "is-type"
             (apply-to (fn [file line type-expr expr]
                         (ast/IsType type-expr expr))
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "is-type")
                       (grmr/get-value 'file-name)
                       (grmr/get-value 'line-number)
                       ignore-whitespace
                       (grmr/any (apply-to (fn [proto-sym type-sym]
                                             (ast/GetImpl proto-sym type-sym c/top-type))
                                           (grmr/ignore "(#impl")
                                           ignore-whitespace
                                           read-symbol
                                           ignore-whitespace
                                           (grmr/optional read-symbol c/no-symbol)
                                           read-close-paren)
                                 read-expr)
                       read-expected-type
                       read-close-paren)))

(def read-show-type
  (grmr/rule "show-type"
             (apply-to (fn [loc expr]
                         (ast/call-expr [(c/tag "show-type" loc) expr]))
                       read-open-paren
                       ignore-whitespace
                       (grmr/ignore "show-type")
                       (apply-to c/Location
                                 (grmr/get-value 'file-name)
                                 (grmr/get-value 'line-number))
                       ignore-whitespace
                       read-sub-expr
                       read-close-paren)))

(def read-main
  (grmr/rule "main"
             (apply-to ast/annotated
                       read-open-paren
                       (grmr/ignore "main")
                       (grmr/any (apply-to ast/main-fn
                                           read-list-destructure
                                           (grmr/any read-inline-body
                                                     (grmr/one-or-more read-expr)
                                                     (grmr/error "Body of 'main' fn is wrong."))
                                           read-close-paren)
                                 (grmr/error "'main' fn expression is wrong.")))))

(def top-level
  (grmr/rule "top-level"
             (apply-to identity
                       ignore-whitespace
                       ;; (grmr/catch-error output-error)
                       (grmr/any read-defn
                                 read-def
                                 read-defprotocol
                                 read-deftype
                                 read-extend-type
                                 read-block-comment
                                 read-main
                                 ;; read-JS-callable
                                 read-inline
                                 ;; read-add-ns

                                 ;; ;; for core-types.toc
                                 ;; read-show-type
                                 ;; read-is-type

                                 ;; shebang
                                 bad-expr
                                 ;; TODO: detect end of input
                                 ))))
